(define lambda
  (macro (formals . body) env
    (let ((thunk (cons macro (cons formals (cons _ body)))))
      (wrap (eval thunk env)))))

(define defn
  (macro (name formals . body) env
    (let ((d (list define name (cons lambda (cons formals body)))))
      (wrap (eval d env)))))


;;; from the LISP 1.5 Programmer's Manual
(define equal
  (label _equal (lambda (x y) (cond
    ((atom x) (if (atom y) (eq x y) nil))
    ((_equal (car x) (car y)) (_equal (cdr x) (cdr y)))
    (t nil)))))

(define subst
  (lambda (x y z)
    (cond ((eq y z) x)
          ((atom z) z)
          (t (cons (subst x y (car z))
                   (subst x y (cdr z)))))))
(define pairlis
  (label pairlis (lambda (x y a)
    (cond ((null x) a)
          (t (cons (cons (car x) (car y))
                   (pairlis (cdr x) (cdr y) a)))))))
(define assoc
  (lambda (x a)
    (cond ((eq (caar a) x) (car a))
          (t (assoc x (cdr a))))))

(define if
  (macro (pred then else) env

    (eval (list cond (list pred then) (list t else)) env)
    #_(cond ((eval pred env) (eval then env))
            (t               (eval else env)))
    ))


(define apply
  (lambda (appv arg . opt)
    (eval (cons (unwrap appv) arg)
          (if (null opt) (make-environment) (car opt)))))

(define maplist
  (lambda (x fn)
    (cond ((null x) nil)
          (t (cons (fn (car x)) (maplist (cdr x) fn))))))

(defn length (a)
  (cond ((null a) 0)
        ((atom a) 0)
        (t (+ 1 (length (cdr a))))))


(define and
  (macro x e
    (cond ((null x) t)
          ((null (cdr x)) (eval (car x) e))
          ((eval (car x) e) (apply (wrap and) (cdr x) e))
          (t nil))))
